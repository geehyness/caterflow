// src/app/reports/page.tsx
'use client';

import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import {
    Box,
    Heading,
    Text,
    Flex,
    Spinner,
    Button,
    useToast,
    Tabs,
    TabList,
    TabPanels,
    Tab,
    TabPanel,
    Card,
    CardBody,
    VStack,
    HStack,
    Select,
    Input,
    InputGroup,
    InputLeftElement,
    Badge,
    Table,
    Thead,
    Tbody,
    Tr,
    Th,
    Td,
    TableContainer,
    useColorModeValue,
    Icon,
    Alert,
    AlertIcon,
    SimpleGrid,
    Stat,
    StatLabel,
    StatNumber,
    StatHelpText,
} from '@chakra-ui/react';
import { useSession } from 'next-auth/react';
import { FiDownload, FiSearch, FiCalendar, FiFilter, FiTrendingUp, FiPackage, FiTruck, FiRepeat } from 'react-icons/fi';

interface ReportData {
    [key: string]: any;
}

interface ReportConfig {
    title: string;
    description: string;
    endpoint: string;
    columns: string[];
    filters?: {
        dateRange?: boolean;
        site?: boolean;
        status?: boolean;
    };
}

interface AnalyticsData {
    purchaseOrders: any;
    goodsReceipts: any;
    dispatches: any;
    transfers: any;
    binCounts: any;
    lowStock: any;
}

export default function ReportsPage() {
    const { data: session, status } = useSession();
    const [activeTab, setActiveTab] = useState(0); // Analytics tab first
    const [loading, setLoading] = useState<{ [key: string]: boolean }>({});
    const [analyticsLoading, setAnalyticsLoading] = useState(false);
    const [reportData, setReportData] = useState<{ [key: string]: ReportData[] }>({});
    const [filteredData, setFilteredData] = useState<{ [key: string]: ReportData[] }>({});
    const [sites, setSites] = useState<any[]>([]);
    const [searchTerms, setSearchTerms] = useState<{ [key: string]: string }>({});
    const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);
    const toast = useToast();

    // Filter states
    const [selectedSites, setSelectedSites] = useState<{ [key: string]: string }>({});
    const [dateRanges, setDateRanges] = useState<{ [key: string]: { start: string; end: string } }>({});
    const [analyticsDateRange, setAnalyticsDateRange] = useState<{ start: string; end: string }>({
        start: '', // Empty string = no filter
        end: ''    // Empty string = no filter
    });

    // Theme colors - ALL HOOKS MUST BE AT TOP LEVEL
    const bgPrimary = useColorModeValue('neutral.light.bg-primary', 'neutral.dark.bg-primary');
    const bgCard = useColorModeValue('neutral.light.bg-card', 'neutral.dark.bg-card');
    const borderColor = useColorModeValue('neutral.light.border-color', 'neutral.dark.border-color');
    const primaryTextColor = useColorModeValue('neutral.light.text-primary', 'neutral.dark.text-primary');
    const secondaryTextColor = useColorModeValue('neutral.light.text-secondary', 'neutral.dark.text-secondary');
    const tableHeaderBg = useColorModeValue('gray.50', 'gray.700');
    const tableRowHoverBg = useColorModeValue('gray.50', 'gray.700');

    // Report configurations using ONLY existing endpoints
    const reportConfigs: ReportConfig[] = useMemo(() => [
        {
            title: 'Purchase Orders',
            description: 'Detailed purchase order history and status',
            endpoint: '/api/purchase-orders',
            columns: ['poNumber', 'orderDate', 'status', 'supplierNames', 'site.name', 'totalAmount', 'orderedItems'],
            filters: {
                dateRange: true,
                site: true,
                status: true
            }
        },
        {
            title: 'Goods Receipts',
            description: 'Goods receipt transactions and inventory updates',
            endpoint: '/api/goods-receipts',
            columns: ['receiptNumber', 'receiptDate', 'status', 'purchaseOrder.poNumber', 'purchaseOrder.site.name', 'receivedItems', 'receivingBin.name'],
            filters: {
                dateRange: true,
                site: true,
                status: true
            }
        },
        {
            title: 'Dispatches',
            description: 'Dispatch records and consumption tracking',
            endpoint: '/api/dispatches',
            columns: ['dispatchNumber', 'dispatchDate', 'dispatchType.name', 'sourceBin.site.name', 'peopleFed', 'totalCost', 'evidenceStatus', 'dispatchedBy.name'],
            filters: {
                dateRange: true,
                site: true,
                status: true
            }
        },
        {
            title: 'Transfers',
            description: 'Internal stock transfers between bins and sites',
            endpoint: '/api/transfers',
            columns: ['transferNumber', 'transferDate', 'status', 'fromBin.site.name', 'toBin.site.name', 'transferredItems', 'requestedBy.name'],
            filters: {
                dateRange: true,
                site: true,
                status: true
            }
        },
        {
            title: 'Bin Counts',
            description: 'Stock counting and variance reports',
            endpoint: '/api/bin-counts',
            columns: ['countNumber', 'countDate', 'status', 'bin.name', 'bin.site.name', 'countedItems', 'totalVariance', 'countedBy.name'],
            filters: {
                dateRange: true,
                site: true,
                status: true
            }
        }
    ], []);

    const currentReport = activeTab > 0 ? reportConfigs[activeTab - 1] : null;

    // Use refs for the filter function to avoid circular dependencies
    const filterStateRef = useRef({
        reportData,
        dateRanges,
        selectedSites,
        searchTerms,
        reportConfigs
    });

    // Update the ref when state changes
    useEffect(() => {
        filterStateRef.current = {
            reportData,
            dateRanges,
            selectedSites,
            searchTerms,
            reportConfigs
        };
    }, [reportData, dateRanges, selectedSites, searchTerms, reportConfigs]);

    // Helper function to get date from item based on report type
    const getItemDate = (item: any, reportTitle: string): string => {
        switch (reportTitle) {
            case 'Purchase Orders':
                return item.orderDate || item.createdAt || '';
            case 'Goods Receipts':
                return item.receiptDate || '';
            case 'Dispatches':
                return item.dispatchDate || '';
            case 'Transfers':
                return item.transferDate || '';
            case 'Bin Counts':
                return item.countDate || '';
            default:
                return item.createdAt || '';
        }
    };

    // Helper function to get site from item based on report type
    const getItemSite = (item: any, reportTitle: string): any => {
        switch (reportTitle) {
            case 'Purchase Orders':
                return item.site;
            case 'Goods Receipts':
                return item.purchaseOrder?.site;
            case 'Dispatches':
                return item.sourceBin?.site;
            case 'Transfers':
                return item.fromBin?.site;
            case 'Bin Counts':
                return item.bin?.site;
            default:
                return item.site;
        }
    };

    // Filter report data - using ref to avoid dependencies
    const filterReportData = useCallback((reportTitle: string, dataToFilter?: ReportData[]) => {
        const { reportData, dateRanges, selectedSites, searchTerms, reportConfigs } = filterStateRef.current;
        
        const data = dataToFilter || reportData[reportTitle];
        if (!data) return;

        const config = reportConfigs.find(r => r.title === reportTitle);
        if (!config) return;

        let filtered = [...data];

        // Apply date range filter
        if (config.filters?.dateRange) {
            filtered = filtered.filter((item: any) => {
                const itemDate = getItemDate(item, reportTitle);
                const dateRange = dateRanges[reportTitle];
                return (!dateRange?.start || itemDate >= dateRange.start) &&
                    (!dateRange?.end || itemDate <= dateRange.end);
            });
        }

        // Apply site filter
        if (config.filters?.site && selectedSites[reportTitle] !== 'all') {
            filtered = filtered.filter((item: any) => {
                const itemSite = getItemSite(item, reportTitle);
                return itemSite === selectedSites[reportTitle] ||
                    (typeof itemSite === 'object' && itemSite._id === selectedSites[reportTitle]);
            });
        }

        // Apply search filter
        const searchTerm = searchTerms[reportTitle];
        if (searchTerm) {
            filtered = filtered.filter(item =>
                Object.values(item).some(value =>
                    value?.toString().toLowerCase().includes(searchTerm.toLowerCase())
                )
            );
        }

        setFilteredData(prev => ({ ...prev, [reportTitle]: filtered }));
    }, []); // No dependencies - uses ref

    // Fetch report data (only if not already loaded)
    const fetchReportData = useCallback(async (reportTitle: string) => {
        if (filterStateRef.current.reportData[reportTitle]) {
            // Data already exists, just apply filters
            filterReportData(reportTitle);
            return;
        }

        setLoading(prev => ({ ...prev, [reportTitle]: true }));
        try {
            const config = filterStateRef.current.reportConfigs.find(r => r.title === reportTitle);
            if (!config) return;

            const response = await fetch(config.endpoint);

            if (!response.ok) {
                throw new Error(`Failed to fetch ${reportTitle} data`);
            }

            let data = await response.json();

            // Store the raw data
            setReportData(prev => ({ ...prev, [reportTitle]: data }));

            // Apply current filters to the new data
            filterReportData(reportTitle, data);
        } catch (error) {
            console.error(`Error fetching ${reportTitle} data:`, error);
            toast({
                title: 'Error',
                description: `Failed to load ${reportTitle} data`,
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setLoading(prev => ({ ...prev, [reportTitle]: false }));
        }
    }, [filterReportData, toast]);

    // Initialize filter states
    useEffect(() => {
        const initialDateRanges: { [key: string]: { start: string; end: string } } = {};
        const initialSelectedSites: { [key: string]: string } = {};
        const initialSearchTerms: { [key: string]: string } = {};

        reportConfigs.forEach(config => {
            initialDateRanges[config.title] = {
                start: new Date(new Date().getFullYear() - 1, 0, 1).toISOString().split('T')[0],
                end: new Date().toISOString().split('T')[0]
            };
            initialSelectedSites[config.title] = 'all';
            initialSearchTerms[config.title] = '';
        });

        setDateRanges(initialDateRanges);
        setSelectedSites(initialSelectedSites);
        setSearchTerms(initialSearchTerms);
    }, [reportConfigs]);

    // Fetch sites
    useEffect(() => {
        const fetchSites = async () => {
            try {
                const response = await fetch('/api/sites');
                if (response.ok) {
                    const data = await response.json();
                    setSites(data);
                }
            } catch (error) {
                console.error('Failed to fetch sites:', error);
            }
        };
        fetchSites();
    }, []);

    // Fetch analytics data
    const fetchAnalyticsData = useCallback(async () => {
        setAnalyticsLoading(true);
        try {
            // Fetch data from multiple endpoints for analytics
            const [purchaseOrders, goodsReceipts, dispatches, transfers, binCounts, lowStock] = await Promise.all([
                fetch('/api/purchase-orders').then(r => r.ok ? r.json() : []),
                fetch('/api/goods-receipts').then(r => r.ok ? r.json() : []),
                fetch('/api/dispatches').then(r => r.ok ? r.json() : []),
                fetch('/api/transfers').then(r => r.ok ? r.json() : []),
                fetch('/api/bin-counts').then(r => r.ok ? r.json() : []),
                fetch('/api/low-stock').then(r => r.ok ? r.json() : [])
            ]);

            console.log('Analytics Data Received:', {
                purchaseOrders: purchaseOrders.length,
                goodsReceipts: goodsReceipts.length,
                dispatches: dispatches.length,
                transfers: transfers.length,
                binCounts: binCounts.length,
                lowStock: lowStock.length
            });

            // Filter data by analytics date range
            const filterByDate = (data: any[], getDateFn: (item: any) => string) => {
                return data.filter((item: any) => {
                    const itemDate = getDateFn(item);
                    if (!itemDate) return true; // Include items without dates

                    return (!analyticsDateRange.start || itemDate >= analyticsDateRange.start) &&
                        (!analyticsDateRange.end || itemDate <= analyticsDateRange.end);
                });
            };

            // Use actual date field names from your data structure
            const filteredPOs = filterByDate(purchaseOrders, (item) => item.orderDate || item._createdAt);
            const filteredGRs = filterByDate(goodsReceipts, (item) => item.receiptDate);
            const filteredDispatches = filterByDate(dispatches, (item) => item.dispatchDate);
            const filteredTransfers = filterByDate(transfers, (item) => item.transferDate);
            const filteredBinCounts = filterByDate(binCounts, (item) => item.countDate);

            console.log('Filtered Analytics Data:', {
                purchaseOrders: filteredPOs.length,
                goodsReceipts: filteredGRs.length,
                dispatches: filteredDispatches.length,
                transfers: filteredTransfers.length,
                binCounts: filteredBinCounts.length
            });

            // Calculate analytics - ensure we're using the filtered data
            const analytics = {
                purchaseOrders: {
                    total: filteredPOs.length,
                    draft: filteredPOs.filter((po: any) => po.status === 'draft').length,
                    pending: filteredPOs.filter((po: any) => po.status === 'pending-approval').length,
                    approved: filteredPOs.filter((po: any) => po.status === 'approved' || po.status === 'processed').length,
                    totalValue: filteredPOs.reduce((sum: number, po: any) => sum + (po.totalAmount || 0), 0)
                },
                goodsReceipts: {
                    total: filteredGRs.length,
                    draft: filteredGRs.filter((gr: any) => gr.status === 'draft').length,
                    partial: filteredGRs.filter((gr: any) => gr.status === 'partially-received').length,
                    completed: filteredGRs.filter((gr: any) => gr.status === 'completed').length
                },
                dispatches: {
                    total: filteredDispatches.length,
                    totalPeopleFed: filteredDispatches.reduce((sum: number, d: any) => sum + (d.peopleFed || 0), 0),
                    totalCost: filteredDispatches.reduce((sum: number, d: any) => sum + (d.totalCost || 0), 0)
                },
                transfers: {
                    total: filteredTransfers.length,
                    pending: filteredTransfers.filter((t: any) => t.status === 'pending-approval').length,
                    approved: filteredTransfers.filter((t: any) => t.status === 'approved').length,
                    completed: filteredTransfers.filter((t: any) => t.status === 'completed').length
                },
                binCounts: {
                    total: filteredBinCounts.length,
                    draft: filteredBinCounts.filter((bc: any) => bc.status === 'draft').length,
                    inProgress: filteredBinCounts.filter((bc: any) => bc.status === 'in-progress').length,
                    completed: filteredBinCounts.filter((bc: any) => bc.status === 'completed' || bc.status === 'adjusted').length
                },
                lowStock: {
                    total: lowStock.length,
                    critical: lowStock.filter((item: any) => (item.currentStock || 0) === 0).length,
                    warning: lowStock.filter((item: any) => (item.currentStock || 0) > 0 && (item.currentStock || 0) <= (item.minimumStockLevel || 0)).length
                }
            };

            console.log('Calculated Analytics:', analytics);
            setAnalyticsData(analytics);
        } catch (error) {
            console.error('Error fetching analytics data:', error);
            toast({
                title: 'Error',
                description: 'Failed to load analytics data',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setAnalyticsLoading(false);
        }
    }, [analyticsDateRange, toast]);

    // Load analytics data on first render and when date range changes
    useEffect(() => {
        if (status === 'authenticated') {
            fetchAnalyticsData();
        }
    }, [fetchAnalyticsData, status]);

    // Load report data when tab changes (only if not already loaded)
    useEffect(() => {
        if (status === 'authenticated' && currentReport) {
            fetchReportData(currentReport.title);
        }
    }, [currentReport, fetchReportData, status]);

    // Export single report to CSV
    const exportToCSV = useCallback((reportTitle: string) => {
        const data = filteredData[reportTitle];
        if (!data || data.length === 0) {
            toast({
                title: 'No Data',
                description: 'There is no data to export',
                status: 'warning',
                duration: 3000,
                isClosable: true,
            });
            return;
        }

        try {
            const config = reportConfigs.find(r => r.title === reportTitle);
            if (!config) return;

            // Transform data for CSV export
            const headers = config.columns.map(col =>
                col.split('.').map(part =>
                    part.replace(/([A-Z])/g, ' $1').trim()
                ).join(' > ')
            ).join(',');

            const csvData = data.map(item => {
                return config.columns.map(column => {
                    const value = getNestedValue(item, column);
                    // Escape CSV values
                    const stringValue = String(value || '').replace(/"/g, '""');
                    return `"${stringValue}"`;
                }).join(',');
            }).join('\n');

            const csv = `${headers}\n${csvData}`;
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${reportTitle.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            toast({
                title: 'Export Successful',
                description: `${reportTitle} data exported to CSV`,
                status: 'success',
                duration: 3000,
                isClosable: true,
            });
        } catch (error) {
            console.error('Error exporting to CSV:', error);
            toast({
                title: 'Export Failed',
                description: 'Failed to export data to CSV',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        }
    }, [filteredData, reportConfigs, toast]);

    // Export all reports to a single organized CSV file
    const exportAllReports = useCallback(async () => {
        try {
            setAnalyticsLoading(true);

            // Fetch all report data
            const fetchPromises = reportConfigs.map(config => {
                return fetch(config.endpoint).then(r => r.ok ? r.json() : []);
            });

            const allData = await Promise.all(fetchPromises);

            let combinedCsv = '';

            // Create a section for each report type
            reportConfigs.forEach((config, reportIndex) => {
                const data = allData[reportIndex] || [];

                if (data.length > 0) {
                    // Add report header
                    combinedCsv += `${config.title}\n`;
                    combinedCsv += `${config.description}\n\n`;

                    // Add column headers
                    const headers = config.columns.map(col =>
                        col.split('.').map(part =>
                            part.replace(/([A-Z])/g, ' $1').trim()
                        ).join(' > ')
                    ).join(',');

                    combinedCsv += headers + '\n';

                    // Add data rows
                    data.forEach((item: any) => {
                        const row = config.columns.map(column => {
                            const value = getNestedValue(item, column);
                            const stringValue = String(value || '').replace(/"/g, '""');
                            return `"${stringValue}"`;
                        }).join(',');

                        combinedCsv += row + '\n';
                    });

                    // Add separator between reports
                    combinedCsv += '\n\n';
                }
            });

            // Create and download the single CSV file
            const blob = new Blob([combinedCsv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `All_Reports_Combined_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            toast({
                title: 'Export Successful',
                description: 'All reports combined into a single CSV file',
                status: 'success',
                duration: 3000,
                isClosable: true,
            });
        } catch (error) {
            console.error('Error exporting all reports:', error);
            toast({
                title: 'Export Failed',
                description: 'Failed to export reports',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setAnalyticsLoading(false);
        }
    }, [reportConfigs, toast]);

    // Helper to get nested object values
    const getNestedValue = (obj: any, path: string) => {
        return path.split('.').reduce((current, key) => {
            return current ? current[key] : undefined;
        }, obj);
    };

    // Update filters and re-filter data
    const updateDateRange = (reportTitle: string, newDateRange: { start: string; end: string }) => {
        setDateRanges(prev => ({ ...prev, [reportTitle]: newDateRange }));
        setTimeout(() => filterReportData(reportTitle), 0);
    };

    const updateSelectedSite = (reportTitle: string, site: string) => {
        setSelectedSites(prev => ({ ...prev, [reportTitle]: site }));
        setTimeout(() => filterReportData(reportTitle), 0);
    };

    const updateSearchTerm = (reportTitle: string, term: string) => {
        setSearchTerms(prev => ({ ...prev, [reportTitle]: term }));
        setTimeout(() => filterReportData(reportTitle), 0);
    };

    if (status === 'loading') {
        return (
            <Flex justifyContent="center" alignItems="center" minH="100vh" bg={bgPrimary}>
                <Spinner size="xl" />
            </Flex>
        );
    }

    return (
        <Box p={{ base: 4, md: 8 }} bg={bgPrimary} minH="100vh">
            <VStack spacing={6} align="stretch">
                {/* Header */}
                <Flex justify="space-between" align={{ base: 'flex-start', md: 'center' }} direction={{ base: 'column', md: 'row' }} gap={4}>
                    <Box>
                        <Heading as="h1" size={{ base: 'xl', md: '2xl' }} color={primaryTextColor} mb={2}>
                            Analytics & Reports
                        </Heading>
                        <Text color={secondaryTextColor}>
                            Comprehensive analytics and exportable reports
                        </Text>
                    </Box>
                    {activeTab === 0 && (
                        <Button
                            leftIcon={<FiDownload />}
                            colorScheme="green"
                            onClick={exportAllReports}
                            isLoading={analyticsLoading}
                        >
                            Export All Reports
                        </Button>
                    )}
                </Flex>

                {/* Main Tabs - Analytics and Reports */}
                <Card bg={bgCard} border="1px" borderColor={borderColor}>
                    <CardBody p={0}>
                        <Tabs variant="enclosed" onChange={setActiveTab} colorScheme="brand" index={activeTab}>
                            <TabList>
                                <Tab>
                                    <HStack spacing={2}>
                                        <Icon as={FiTrendingUp} />
                                        <Text>Analytics</Text>
                                    </HStack>
                                </Tab>
                                <Tab>
                                    <HStack spacing={2}>
                                        <Icon as={FiDownload} />
                                        <Text>Reports</Text>
                                    </HStack>
                                </Tab>
                            </TabList>

                            <TabPanels>
                                {/* Analytics Tab */}
                                <TabPanel>
                                    <VStack spacing={6} align="stretch">
                                        {/* Analytics Date Range Filter */}
                                        <Card variant="outline" borderColor={borderColor}>
                                            <CardBody>
                                                <VStack align="start" spacing={4}>
                                                    <Text fontWeight="medium">Analytics Time Period</Text>
                                                    <HStack>
                                                        <Input
                                                            type="date"
                                                            value={analyticsDateRange.start}
                                                            onChange={(e) => setAnalyticsDateRange(prev => ({ ...prev, start: e.target.value }))}
                                                            size="sm"
                                                        />
                                                        <Text>to</Text>
                                                        <Input
                                                            type="date"
                                                            value={analyticsDateRange.end}
                                                            onChange={(e) => setAnalyticsDateRange(prev => ({ ...prev, end: e.target.value }))}
                                                            size="sm"
                                                        />
                                                    </HStack>
                                                    <HStack>
                                                        <Button
                                                            leftIcon={<FiFilter />}
                                                            onClick={fetchAnalyticsData}
                                                            isLoading={analyticsLoading}
                                                            colorScheme="brand"
                                                            size="sm"
                                                        >
                                                            Update Filter
                                                        </Button>
                                                        <Button
                                                            variant="outline"
                                                            onClick={() => {
                                                                setAnalyticsDateRange({
                                                                    start: '',
                                                                    end: ''
                                                                });
                                                            }}
                                                            size="sm"
                                                        >
                                                            View All
                                                        </Button>
                                                    </HStack>
                                                    <Text fontSize="sm" color={secondaryTextColor}>
                                                        {analyticsDateRange.start && analyticsDateRange.end
                                                            ? `Showing data from ${new Date(analyticsDateRange.start).toLocaleDateString()} to ${new Date(analyticsDateRange.end).toLocaleDateString()}`
                                                            : 'Showing all data (no date filter)'
                                                        }
                                                    </Text>
                                                </VStack>
                                            </CardBody>
                                        </Card>

                                        {analyticsLoading ? (
                                            <Flex justify="center" align="center" py={10}>
                                                <Spinner size="xl" />
                                            </Flex>
                                        ) : !analyticsData ? (
                                            <Alert status="info" borderRadius="md">
                                                <AlertIcon />
                                                No analytics data available.
                                            </Alert>
                                        ) : (
                                            <>
                                                {/* Overview Stats */}
                                                <SimpleGrid columns={{ base: 1, md: 2, lg: 3 }} spacing={6}>
                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Stat>
                                                                <StatLabel>Purchase Orders</StatLabel>
                                                                <StatNumber>{analyticsData.purchaseOrders?.total || 0}</StatNumber>
                                                                <StatHelpText>
                                                                    {analyticsData.purchaseOrders?.draft || 0} draft, {analyticsData.purchaseOrders?.pending || 0} pending
                                                                </StatHelpText>
                                                            </Stat>
                                                        </CardBody>
                                                    </Card>

                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Stat>
                                                                <StatLabel>Goods Receipts</StatLabel>
                                                                <StatNumber>{analyticsData.goodsReceipts?.total || 0}</StatNumber>
                                                                <StatHelpText>
                                                                    {analyticsData.goodsReceipts?.completed || 0} completed, {analyticsData.goodsReceipts?.partial || 0} partial
                                                                </StatHelpText>
                                                            </Stat>
                                                        </CardBody>
                                                    </Card>

                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Stat>
                                                                <StatLabel>Dispatches</StatLabel>
                                                                <StatNumber>{analyticsData.dispatches?.total || 0}</StatNumber>
                                                                <StatHelpText>
                                                                    {analyticsData.dispatches?.totalPeopleFed || 0} people fed
                                                                </StatHelpText>
                                                            </Stat>
                                                        </CardBody>
                                                    </Card>

                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Stat>
                                                                <StatLabel>Transfers</StatLabel>
                                                                <StatNumber>{analyticsData.transfers?.total || 0}</StatNumber>
                                                                <StatHelpText>
                                                                    {analyticsData.transfers?.pending || 0} pending, {analyticsData.transfers?.completed || 0} completed
                                                                </StatHelpText>
                                                            </Stat>
                                                        </CardBody>
                                                    </Card>

                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Stat>
                                                                <StatLabel>Bin Counts</StatLabel>
                                                                <StatNumber>{analyticsData.binCounts?.total || 0}</StatNumber>
                                                                <StatHelpText>
                                                                    {analyticsData.binCounts?.draft || 0} draft, {analyticsData.binCounts?.completed || 0} completed
                                                                </StatHelpText>
                                                            </Stat>
                                                        </CardBody>
                                                    </Card>

                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Stat>
                                                                <StatLabel>Low Stock Items</StatLabel>
                                                                <StatNumber>{analyticsData.lowStock?.total || 0}</StatNumber>
                                                                <StatHelpText>
                                                                    {analyticsData.lowStock?.critical || 0} critical, {analyticsData.lowStock?.warning || 0} warning
                                                                </StatHelpText>
                                                            </Stat>
                                                        </CardBody>
                                                    </Card>
                                                </SimpleGrid>

                                                {/* Detailed Analytics */}
                                                <SimpleGrid columns={{ base: 1, lg: 2 }} spacing={6}>
                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Heading size="md" mb={4}>Financial Overview</Heading>
                                                            <VStack align="stretch" spacing={3}>
                                                                <Flex justify="space-between">
                                                                    <Text>Total PO Value:</Text>
                                                                    <Text fontWeight="bold">E {(analyticsData.purchaseOrders?.totalValue || 0).toFixed(2)}</Text>
                                                                </Flex>
                                                                <Flex justify="space-between">
                                                                    <Text>Total Dispatch Cost:</Text>
                                                                    <Text fontWeight="bold">E {(analyticsData.dispatches?.totalCost || 0).toFixed(2)}</Text>
                                                                </Flex>
                                                                <Flex justify="space-between">
                                                                    <Text>Cost per Person:</Text>
                                                                    <Text fontWeight="bold">
                                                                        ${((analyticsData.dispatches?.totalCost || 0) / Math.max(analyticsData.dispatches?.totalPeopleFed || 1, 1)).toFixed(2)}
                                                                    </Text>
                                                                </Flex>
                                                            </VStack>
                                                        </CardBody>
                                                    </Card>

                                                    <Card border="1px" borderColor={borderColor}>
                                                        <CardBody>
                                                            <Heading size="md" mb={4}>Operational Status</Heading>
                                                            <VStack align="stretch" spacing={3}>
                                                                <Flex justify="space-between">
                                                                    <Text>Pending Approvals:</Text>
                                                                    <Badge colorScheme="orange">
                                                                        {(analyticsData.purchaseOrders?.pending || 0) + (analyticsData.transfers?.pending || 0)}
                                                                    </Badge>
                                                                </Flex>
                                                                <Flex justify="space-between">
                                                                    <Text>Draft Items:</Text>
                                                                    <Badge colorScheme="gray">
                                                                        {(analyticsData.purchaseOrders?.draft || 0) + (analyticsData.goodsReceipts?.draft || 0) + (analyticsData.binCounts?.draft || 0)}
                                                                    </Badge>
                                                                </Flex>
                                                                <Flex justify="space-between">
                                                                    <Text>Completed This Period:</Text>
                                                                    <Badge colorScheme="green">
                                                                        {(analyticsData.goodsReceipts?.completed || 0) + (analyticsData.transfers?.completed || 0) + (analyticsData.binCounts?.completed || 0)}
                                                                    </Badge>
                                                                </Flex>
                                                            </VStack>
                                                        </CardBody>
                                                    </Card>
                                                </SimpleGrid>
                                            </>
                                        )}
                                    </VStack>
                                </TabPanel>

                                {/* Reports Tab */}
                                <TabPanel>
                                    <Tabs variant="line" colorScheme="brand">
                                        <TabList overflowX="auto" whiteSpace="nowrap" py={1}>
                                            {reportConfigs.map((config, index) => (
                                                <Tab
                                                    key={config.title}
                                                    flexShrink={0}
                                                    minW="max-content"
                                                    px={4}
                                                    py={3}
                                                >
                                                    {config.title}
                                                </Tab>
                                            ))}
                                        </TabList>

                                        <TabPanels>
                                            {reportConfigs.map((config) => (
                                                <TabPanel key={config.title}>
                                                    <VStack spacing={4} align="stretch">
                                                        {/* Report Description */}
                                                        <Text color={secondaryTextColor} fontSize="lg">
                                                            {config.description}
                                                        </Text>

                                                        {/* Filters */}
                                                        {(config.filters?.dateRange || config.filters?.site) && (
                                                            <Card variant="outline" borderColor={borderColor}>
                                                                <CardBody>
                                                                    <Flex direction={{ base: 'column', md: 'row' }} gap={4} align={{ base: 'stretch', md: 'end' }}>
                                                                        {config.filters?.dateRange && (
                                                                            <VStack align="start" spacing={2} flex={1}>
                                                                                <Text fontWeight="medium" fontSize="sm">Date Range</Text>
                                                                                <HStack>
                                                                                    <Input
                                                                                        type="date"
                                                                                        value={dateRanges[config.title]?.start || ''}
                                                                                        onChange={(e) => updateDateRange(config.title, {
                                                                                            ...dateRanges[config.title],
                                                                                            start: e.target.value
                                                                                        })}
                                                                                        size="sm"
                                                                                    />
                                                                                    <Text>to</Text>
                                                                                    <Input
                                                                                        type="date"
                                                                                        value={dateRanges[config.title]?.end || ''}
                                                                                        onChange={(e) => updateDateRange(config.title, {
                                                                                            ...dateRanges[config.title],
                                                                                            end: e.target.value
                                                                                        })}
                                                                                        size="sm"
                                                                                    />
                                                                                </HStack>
                                                                            </VStack>
                                                                        )}

                                                                        {config.filters?.site && (
                                                                            <VStack align="start" spacing={2} flex={1}>
                                                                                <Text fontWeight="medium" fontSize="sm">Site</Text>
                                                                                <Select
                                                                                    value={selectedSites[config.title] || 'all'}
                                                                                    onChange={(e) => updateSelectedSite(config.title, e.target.value)}
                                                                                    size="sm"
                                                                                >
                                                                                    <option value="all">All Sites</option>
                                                                                    {sites.map(site => (
                                                                                        <option key={site._id} value={site._id}>
                                                                                            {site.name}
                                                                                        </option>
                                                                                    ))}
                                                                                </Select>
                                                                            </VStack>
                                                                        )}

                                                                        <Button
                                                                            leftIcon={<FiDownload />}
                                                                            onClick={() => exportToCSV(config.title)}
                                                                            isDisabled={!filteredData[config.title] || filteredData[config.title].length === 0}
                                                                            colorScheme="green"
                                                                            size="sm"
                                                                        >
                                                                            Export CSV
                                                                        </Button>
                                                                    </Flex>
                                                                </CardBody>
                                                            </Card>
                                                        )}

                                                        {/* Search */}
                                                        <InputGroup maxW="400px">
                                                            <InputLeftElement pointerEvents="none">
                                                                <Icon as={FiSearch} color={secondaryTextColor} />
                                                            </InputLeftElement>
                                                            <Input
                                                                placeholder="Search in report..."
                                                                value={searchTerms[config.title] || ''}
                                                                onChange={(e) => updateSearchTerm(config.title, e.target.value)}
                                                                borderColor={borderColor}
                                                            />
                                                        </InputGroup>

                                                        {/* Data Table */}
                                                        {loading[config.title] ? (
                                                            <Flex justify="center" align="center" py={10}>
                                                                <Spinner size="xl" />
                                                            </Flex>
                                                        ) : !filteredData[config.title] || filteredData[config.title].length === 0 ? (
                                                            <Alert status="info" borderRadius="md">
                                                                <AlertIcon />
                                                                No data found for the selected filters.
                                                            </Alert>
                                                        ) : (
                                                            <Box overflowX="auto">
                                                                <TableContainer border="1px" borderColor={borderColor} borderRadius="md">
                                                                    <Table variant="simple" size="sm">
                                                                        <Thead bg={tableHeaderBg}>
                                                                            <Tr>
                                                                                {config.columns.map(column => (
                                                                                    <Th key={column} textTransform="capitalize" borderColor={borderColor}>
                                                                                        {column.split('.').map(part =>
                                                                                            part.replace(/([A-Z])/g, ' $1').trim()
                                                                                        ).join(' > ')}
                                                                                    </Th>
                                                                                ))}
                                                                            </Tr>
                                                                        </Thead>
                                                                        <Tbody>
                                                                            {filteredData[config.title].slice(0, 100).map((row, index) => (
                                                                                <Tr key={index} _hover={{ bg: tableRowHoverBg }}>
                                                                                    {config.columns.map(column => (
                                                                                        <Td key={column} borderColor={borderColor}>
                                                                                            {renderCellValue(getNestedValue(row, column), column)}
                                                                                        </Td>
                                                                                    ))}
                                                                                </Tr>
                                                                            ))}
                                                                        </Tbody>
                                                                    </Table>
                                                                </TableContainer>
                                                                {filteredData[config.title].length > 100 && (
                                                                    <Text fontSize="sm" color={secondaryTextColor} mt={2} textAlign="center">
                                                                        Showing first 100 records of {filteredData[config.title].length}. Export to CSV to see all data.
                                                                    </Text>
                                                                )}
                                                            </Box>
                                                        )}
                                                    </VStack>
                                                </TabPanel>
                                            ))}
                                        </TabPanels>
                                    </Tabs>
                                </TabPanel>
                            </TabPanels>
                        </Tabs>
                    </CardBody>
                </Card>
            </VStack>
        </Box>
    );
}

// Helper function to render cell values appropriately
function renderCellValue(value: any, column: string): React.ReactNode {
    if (value == null) return '-';

    // Format dates
    if (column.includes('date') || column.includes('Date') || column === 'timestamp' || column === 'createdAt') {
        try {
            return new Date(value).toLocaleDateString();
        } catch {
            return value;
        }
    }

    // Format currency
    if (column.includes('amount') || column.includes('cost') || column.includes('price')) {
        if (typeof value === 'number') {
            return `$${value.toFixed(2)}`;
        }
    }

    // Format status with badges
    if (column === 'status' || column.includes('Status')) {
        const getStatusColor = (status: string) => {
            switch (status?.toLowerCase()) {
                case 'completed':
                case 'approved':
                case 'processed':
                    return 'green';
                case 'pending':
                case 'draft':
                case 'pending-approval':
                    return 'orange';
                case 'cancelled':
                case 'rejected':
                    return 'red';
                case 'partially-received':
                case 'in-progress':
                    return 'blue';
                default:
                    return 'gray';
            }
        };

        return (
            <Badge colorScheme={getStatusColor(value)} variant="subtle" fontSize="xs">
                {typeof value === 'string' ? value.replace('-', ' ').toUpperCase() : String(value)}
            </Badge>
        );
    }

    // Handle arrays (like items)
    if (Array.isArray(value)) {
        if (value.length === 0) return 'None';

        return value.slice(0, 2).map((item, idx) => (
            <Text key={idx} fontSize="xs">
                {typeof item === 'object' ?
                    (item.stockItem?.name || item.name || `${item.orderedQuantity || item.receivedQuantity || item.dispatchedQuantity || item.quantity}x item`) :
                    String(item)}
            </Text>
        )).concat(value.length > 2 ? [<Text key="more" fontSize="xs">+{value.length - 2} more</Text>] : []);
    }

    // Handle objects
    if (typeof value === 'object') {
        return value.name || value.title || value.poNumber || value.receiptNumber || value.dispatchNumber || value.transferNumber || 'Object';
    }

    return String(value);
}